<!-- 
  shim.htc: an html5 shim (github.com/chjj) 
  (c) Copyright 2011, Christopher Jeffrey (MIT Licensed) 
-->
<public:component lightweight="true">
  <public:attach event="ondocumentready" 
    for="element" onevent="shim()"/>
</public:component>

<script language="JScript">
  var shim = function() {
    if (function() { 
      var el = element.document.createElement('b');
      el.innerHTML = '<nav></nav>';
      return el.childNodes.length > 0;
    }()) return;

    var doc = element.document
      , head = doc.getElementsByTagName('head')[0]
      , body = doc.body
      , names = new RegExp(
          '^(abbr|article|aside|audio|canvas|details|figcaption'
          + '|figure|footer|header|hgroup|mark|meter|nav|output'
          + '|progress|section|summary|time|video)$', 
        'i');

    // move any html5 elements out of the head:
    // if the BODY/HEAD tags are omitted with html5 elements present, 
    // IE doesn't know which elements to implicitly include in the 
    // HEAD, so it ends up putting any bugged html5 start-tags there. 
    // we need to move them into the BODY before we can fix things.
    while (names.test(head.lastChild.nodeName)) {
      body.insertBefore(head.lastChild, body.firstChild);
    }

    // mutable variables used during the walk
    var all = body.getElementsByTagName('*')
      , i = 0, cur, el, attr, val, depth
      , start, close, next;

    // walk the dom tree and fix the structure accordingly
    while (cur = all[i++]) {
      if (names.test(cur.nodeName) && !cur.firstChild) {
        // turn all the bugged "start-tag" 
        // elements into their real counterparts
        el = doc.createElement(cur.nodeName);
        for (attr in cur.attributes) {
          if (val = cur.getAttribute(attr)) {
            el.setAttribute(attr, val);
          }
        }
        cur.parentNode.replaceChild(el, cur);

        // append all elements until the corresponding 
        // bugged "close-tag" element is found
        start = el.nodeName, close = '/' + start, depth = 0;
        while (next = el.nextSibling) {
          if (next.nodeName === start) {
            depth++;
          } else if (next.nodeName === close) {
            if (!depth--) break;
          }
          el.appendChild(next);
        }

        // get rid of the bugged "close-tag" element
        // shouldnt need to check for a nextSibling if everything went 
        // accordingly (there should always be a nextSibling),
        // but it cant hurt to do just for good measure
        if (el.nextSibling) el.parentNode.removeChild(el.nextSibling); 
      }
    }
  };
</script>